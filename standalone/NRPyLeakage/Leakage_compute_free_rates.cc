#include "Basic_defines.hh"
#include "Leakage.hh"
#include "WVU_EOS_Tabulated_headers.hh"

/*
 * (c) Leo Werneck
 * Compute free neutrino emission and cooling rates following
 * Ruffert et al. (1996)
 * https://adsabs.harvard.edu/pdf/1996A%26A...311..532R
 */
extern "C"
void Leakage_compute_free_rates(const REAL rho_b,
                const REAL Y_e,
                const REAL T,
                const REAL tau_nue,
                const REAL tau_anue,
                REAL *restrict R_free_total_nue ,
                REAL *restrict R_free_total_anue,
                REAL *restrict R_free_total_nux ,
                REAL *restrict Q_free_total_nue ,
                REAL *restrict Q_free_total_anue,
                REAL *restrict Q_free_total_nux) {


  // Step 1: Get chemical potentials and mass
  //         fractions using the EOS
  REAL mu_e, mu_n, mu_p, muhat, X_n, X_p;
  WVU_EOS_mue_mup_mun_muhat_Xn_and_Xp_from_rho_Ye_T(rho_b, Y_e, T,
                                                    &mu_e, &mu_p, &mu_n, &muhat, &X_p, &X_n);
                                                    
  // Step 2: Compute rho_b in cgs units
  const REAL rho_b_cgs = rho_b * Leakage::units_geom_to_cgs_density;

  // Step 3: Compute Y_{pn} and Y_{np}
  // Step 3.a: Compute Y_{pn} (See discussion below Eq. A8 in https://arxiv.org/pdf/1306.4953.pdf)
  REAL Y_pn,Y_np;
  if( Y_e < 0.5 ) {
    Y_np = (2*Y_e - 1)/(1-exp(-muhat/T));
  }
  else {
    Y_np = 1.0-Y_e;
  }
  if( Y_e > 0.5 ) {
    // Step 3.a.i: Use Eqs. (A13) and (A14) in https://adsabs.harvard.edu/pdf/1996A%26A...311..532R
    Y_pn = (2*Y_e - 1)/(1-exp(muhat/T));
  }
  else {
    Y_pn = Y_e;
  }
  // Step 3.a.ii: Make sure Y_{pn} is nonzero
  // Y_pn = MAX(Y_pn,0.0);
  // Y_np = MAX(Y_np,0.0);
  
  // Step 3.b: Compute Y_{np} (Eq. A13 in https://adsabs.harvard.edu/pdf/1996A%26A...311..532R)
  // const REAL Y_np = exp(muhat/T) * Y_pn;

  // Step 4: The code below is generated by NRPy+
  const REAL tmp_0 = (1.0/(T));
  const REAL tmp_1 = mu_e*tmp_0;
  const REAL tmp_2 = Leakage_Fermi_Dirac_integrals(4, tmp_1);
  const REAL tmp_3 = 8*Leakage::N_A*Leakage::beta*M_PI*rho_b_cgs*((3.0/8.0)*((Leakage::alpha)*(Leakage::alpha)) + 1.0/8.0)/Leakage::hc3;
  const REAL tmp_4 = ((T)*(T)*(T)*(T)*(T))*tmp_3;
  const REAL tmp_5 = Leakage_Fermi_Dirac_integrals(5, tmp_1);
  const REAL tmp_6 = exp(-tau_nue);
  const REAL tmp_10 = Leakage::eta_nue_0*tmp_6 + (1 - tmp_6)*(-Leakage::Q_npmass*tmp_0 - mu_n*tmp_0 + mu_p*tmp_0 + tmp_1);
  const REAL tmp_11 = Y_pn/(exp(tmp_10 - tmp_5/tmp_2) + 1);
  const REAL tmp_12 = Leakage::Brems_zeta*rho_b_cgs*(((X_n)*(X_n)) + (28.0/3.0)*X_n*X_p + ((X_p)*(X_p)));
  const REAL tmp_13 = Leakage::Brems_C1*pow(T, 4.5)*tmp_12;
  const REAL tmp_14 = Leakage_Fermi_Dirac_integrals(3, tmp_1);
  const REAL tmp_16 = Leakage_Fermi_Dirac_integrals(4, -tmp_1);
  const REAL tmp_17 = Leakage_Fermi_Dirac_integrals(3, -tmp_1);
  const REAL tmp_18 = -1.0/2.0*tmp_16/tmp_17 - 1.0/2.0*tmp_2/tmp_14;
  const REAL tmp_19 = exp(-tau_anue);
  const REAL tmp_20 = Leakage::eta_anue_0*tmp_19 + (1 - tmp_19)*(Leakage::Q_npmass*tmp_0 + mu_n*tmp_0 - mu_p*tmp_0 - tmp_1);
  const REAL tmp_21 = Leakage::C1pC2_nue_anue/((exp(tmp_10 + tmp_18) + 1)*(exp(tmp_18 + tmp_20) + 1));
  const REAL tmp_22 = ((M_PI)*(M_PI));
  const REAL tmp_24 = (1.0/((Leakage::hc3)*(Leakage::hc3)));
  const REAL tmp_25 = Leakage::beta*pow(T, 8)*tmp_24;
  const REAL tmp_26 = tmp_14*tmp_17*tmp_22*tmp_25;
  const REAL tmp_27 = (1.0/3.0)*tmp_22 + ((mu_e)*(mu_e))/((T)*(T));
  const REAL tmp_28 = Leakage::gamma_0*sqrt(tmp_27);
  const REAL tmp_30 = pow(Leakage::gamma_0, 6)*((M_PI)*(M_PI)*(M_PI))*((tmp_27)*(tmp_27)*(tmp_27))*(tmp_28 + 1)*exp(-tmp_28)/Leakage::alpha_fs;
  const REAL tmp_31 = (1.0/3.0)*tmp_25*tmp_30;
  const REAL tmp_32 = ((Leakage::gamma_0)*(Leakage::gamma_0))*tmp_27/(tmp_28 + 1);
  const REAL tmp_33 = -1.0/2.0*tmp_32 - 1;
  const REAL tmp_34 = ((Leakage::C_V)*(Leakage::C_V))/((exp(tmp_10 + tmp_33) + 1)*(exp(tmp_20 + tmp_33) + 1));
  const REAL tmp_35 = tmp_13 + (16.0/9.0)*tmp_21*tmp_26 + tmp_31*tmp_34;
  const REAL tmp_36 = Leakage_Fermi_Dirac_integrals(5, -tmp_1);
  const REAL tmp_37 = Y_np/(exp(tmp_20 - tmp_36/tmp_16) + 1);
  const REAL tmp_38 = Leakage::C1pC2_nux_anux/((exp(tmp_18) + 1)*(exp(tmp_18) + 1));
  const REAL tmp_39 = ((Leakage::C_V - 1)*(Leakage::C_V - 1))/((exp(tmp_33) + 1)*(exp(tmp_33) + 1));
  const REAL tmp_40 = pow(T, 6)*tmp_3;
  const REAL tmp_41 = Leakage::Brems_C2*pow(T, 5.5)*tmp_12;
  const REAL tmp_42 = pow(T, 9)*tmp_24;
  const REAL tmp_44 = Leakage::beta*(32*tmp_14*tmp_16*tmp_22*tmp_42 + 32*tmp_17*tmp_2*tmp_22*tmp_42);
  const REAL tmp_45 = (1.0/6.0)*Leakage::beta*tmp_30*tmp_42*(tmp_32 + 2);
  const REAL tmp_46 = (1.0/36.0)*tmp_21*tmp_44 + tmp_34*tmp_45 + tmp_41;
  *R_free_total_nue = tmp_11*tmp_2*tmp_4 + tmp_35;
  *R_free_total_anue = tmp_16*tmp_37*tmp_4 + tmp_35;
  *R_free_total_nux = tmp_13 + (64.0/9.0)*tmp_26*tmp_38 + tmp_31*tmp_39;
  *Q_free_total_nue = tmp_11*tmp_40*tmp_5 + tmp_46;
  *Q_free_total_anue = tmp_36*tmp_37*tmp_40 + tmp_46;
  *Q_free_total_nux = (1.0/9.0)*tmp_38*tmp_44 + tmp_39*tmp_45 + tmp_41;
  printf("%.15e\n",tmp_11*tmp_2*tmp_4);
  printf("%.15e\n",tmp_16*tmp_37*tmp_4);
}
